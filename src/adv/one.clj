(ns adv.one
  (:require [clojure.string :as str]
            [adv.utils :as u]))

;; Part 1

(def examples-pt1
  "A map of example input and their answers for part 1"
  {"1122" 3
   "1111" 4
   "1234" 0
   "91212129" 9})

(defn parse
  "Parses a string of digits and appends the first digit to the end.
  This simulates a circular list"
  [input]
  (mapv #(Character/digit % 10) input))

(defn fake-circular
  [coll]
  (conj coll (first coll)))


(defn all-pairs
  [coll]
  (partition 2 1 coll))

(defn match?
  "If the pair matches return the digit otherwise return nil"
  [pair]
  (when (= (first pair) (second pair))
    (first pair)))

(def matches
  "A transducer that gives us only the numbers of the matched paris"
  (comp
   (map match?)
   (filter (complement nil?))))

(defn sum-matches
  "Sums the numbers of the matched pairs"
  [coll]
  (transduce matches + 0 coll))

(defn sum-input
  "Parses the input and then sums the numbers of the matched pairs"
  [input]
  (->> input
      (parse)
      (fake-circular)
      (all-pairs)
      (sum-matches)))

;; Test the test inputs
(u/test-examples sum-input examples-pt1)
;; => true

;; Now for the actual input
(def input
  "My input for this challenge"
  "77736991856689225253142335214746294932318813454849177823468674346512426482777696993348135287531487622845155339235443718798255411492778415157351753377959586612882455464736285648473397681163729345143319577258292849619491486748832944425643737899293811819448271546283914592546989275992844383947572926628695617661344293284789225493932487897149244685921644561896799491668147588536732985476538413354195246785378443492137893161362862587297219368699689318441563683292683855151652394244688119527728613756153348584975372656877565662527436152551476175644428333449297581939357656843784849965764796365272113837436618857363585783813291999774718355479485961244782148994281845717611589612672436243788252212252489833952785291284935439662751339273847424621193587955284885915987692812313251556836958571335334281322495251889724281863765636441971178795365413267178792118544937392522893132283573129821178591214594778712292228515169348771198167462495988252456944269678515277886142827218825358561772588377998394984947946121983115158951297156321289231481348126998584455974277123213413359859659339792627742476688827577318285573236187838749444212666293172899385531383551142896847178342163129883523694183388123567744916752899386265368245342587281521723872555392212596227684414269667696229995976182762587281829533181925696289733325513618571116199419759821597197636415243789757789129824537812428338192536462468554399548893532588928486825398895911533744671691387494516395641555683144968644717265849634943691721391779987198764147667349266877149238695714118982841721323853294642175381514347345237721288281254828745122878268792661867994785585131534136646954347165597315643658739688567246339618795777125767432162928257331951255792438831957359141651634491912746875748363394329848227391812251812842263277229514125426682179711184717737714178235995431465217547759282779499842892993556918977773236196185348965713241211365895519697294982523166196268941976859987925578945185217127344619169353395993198368185217391883839449331638641744279836858188235296951745922667612379649453277174224722894599153367373494255388826855322712652812127873536473277")

(sum-input input)
;; => 1223

;;; Part 2

(def examples-pt2
  "A map of example input and their answers for part 1"
  {"1212" 6
   "1221" 0
   "123425" 4
   "123123" 12
   "12131415" 4})

(defn circular-get
  "Performs a get by index, but when n is larger than "
  [coll n]
  (get coll (mod n (count coll))))

(defn all-halfway-pairs
  "Creates a seq of pairs of each number and the number halfway around the coll.

  E.g: [1 2 3 4] => [(1 3) (2 4) (3 1) (4 2)]"
  [coll]
  (let [len (count coll)
        rot (/ len 2)] ;; The problem says we'll only get even length inputs so this is fine
    (loop [acc []
           idx 0]
      (if (= len idx)
        acc
        (recur (conj acc [(get coll idx)
                          (circular-get coll (+ idx rot))])
               (inc idx))))))

(defn sum-halfway-inputs
  "Parses the input and then sums the numbers of the matched pairs"
  [input]
  (->> input
       (parse)
       (all-halfway-pairs)
       (sum-matches)))

;; Test the test inputs
(u/test-examples sum-halfway-inputs examples-pt2)
;; => true

;; Now for the actual input
(sum-halfway-inputs input)
;; => 1284
